{"version":3,"sources":["../../src/scheduler/index.ts","../../src/log.ts","../../src/util/function.ts"],"sourcesContent":["import { noneLogger } from \"@/log\"\nimport { TimeConstraint, Timing } from \"@/timing/contract\"\nimport { calculateMilliseconds } from \"@/util/function\"\nimport { setTimeout } from \"timers/promises\"\nimport { Logger } from \"winston\"\n\nexport type Mode = (ShotMode | LoopMode) & { _type: string }\n\nexport type ShotMode = {\n    _type: \"shot\"\n}\n\nexport type LoopMode = {\n    _type: \"loop\"\n    oneCycleTime: { h: number, m: number }\n}\n\nexport class Scheduler {\n    private readonly logger: Logger\n\n    constructor(\n        private readonly mode: Mode,\n        private readonly timing: Timing,\n        private readonly tasks: Task[],\n        logger?: Logger,\n    ) {\n        this.logger = logger || noneLogger()\n    }\n\n    async run() {\n        this.logger.debug(`run`, { mode: this.mode._type })\n        switch (this.mode._type) {\n            case 'shot':\n                await this.oneCycle()\n                break\n            case 'loop':\n                await this.loop(this.mode.oneCycleTime)\n                break\n        }\n    }\n\n    private async oneCycle() {\n        for (const task of this.tasks) {\n            this.logger.info(`start ${task.name}`, { task_name: task.name })\n            try {\n                const input = {\n                    key: task.name,\n                    date: new Date(),\n                }\n\n                if (!await this.timing.allow(input)) {\n                    this.logger.info(`skip ${task.name}`, { task_name: task.name })\n                    continue\n                }\n\n                await task.fn()\n                await this.timing.complete({\n                    ...input,\n                    constraint: task.constraint\n                })\n                this.logger.info(`end ${task.name}`, { task_name: task.name })\n            } catch (e) {\n                //\n            }\n        }\n    }\n\n    private async loop(oneCycleTime: { h: number, m: number }) {\n        // ループの最低時間\n        const totalSleepMs = calculateMilliseconds(oneCycleTime);\n        let running = true\n        const controller = new AbortController();\n\n        const signalHandle = () => {\n            running = false;  // ループを停止する\n            controller.abort(); // sleepを中断\n        }\n\n        process.on('SIGINT', () => {\n            signalHandle()\n        });\n        process.on('SIGTERM', () => {\n            signalHandle()\n        });\n        process.on('SIGQUIT', () => {\n            signalHandle()\n        });\n\n        try {\n            while (running) {\n                // スタート時刻を計測\n                const startTime = Date.now()\n                this.logger.debug(\"start oneCycle\")\n\n                await this.oneCycle()\n\n                const endTime = Date.now()\n                this.logger.debug(\"end oneCycle\")\n                const elapsedTime = endTime - startTime // 処理にかかった時間を計測\n\n                // 残り時間の計算\n                const remainingSleepTime = totalSleepMs - elapsedTime\n\n                if (remainingSleepTime > 0 && running) {\n                    this.logger.debug(\"sleep\", { sleep_time_ms: remainingSleepTime, sleep_time_s: remainingSleepTime / 1000, sleep_time_m: remainingSleepTime / (1000 * 60) })\n                    await setTimeout(remainingSleepTime, null, { signal: controller.signal }) // 残り時間をスリープ\n                }\n            }\n        } catch (e) {\n            if (e instanceof Error && e.name === \"AbortError\") {\n                this.logger.info(\"\", e)\n                // 正常なのでスルー\n                this.logger.debug(\"stopping\")\n            } else {\n                throw e\n            }\n        }\n    }\n}\n\nexport type Task = {\n    name: string,\n    constraint: TimeConstraint,\n    fn: () => Promise<void>\n}\n","import { createLogger, format, Logger, transports } from \"winston\";\n\nexport const noneLogger = (): Logger => {\n    return createLogger({\n        transports: [\n            new transports.Console({\n                silent: true\n            })\n        ]\n    })\n}\n\nexport const defaultLogger = (level: string): Logger => {\n    return createLogger({\n        level,\n        format: format.combine(\n            format.timestamp(),\n            format.json()\n        ),\n        transports: [\n            new transports.Console({\n                silent: false // ログ出力を有効化\n            })\n        ]\n    })\n}\n","export type SleepInput = {\n    h?: number,\n    m?: number,\n    s?: number,\n    ms?: number,\n}\n\nexport function calculateMilliseconds({\n    h, m, s, ms,\n}: SleepInput): number {\n    const toM = (h: number) => h * 60\n    const toS = (m: number) => m * 60\n    const toMS = (s: number) => s * 1000\n\n    return toMS(\n        toS(\n            toM(\n                h || 0\n            ) + (m || 0)\n        ) + (s || 0)\n    ) + (ms || 0)\n}\n\n"],"mappings":"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","names":["h","m","s"]}