{"version":3,"sources":["../../src/timing/index.ts","../../src/timing/concrete/file.ts","../../src/timing/concrete/redis.ts","../../src/timing/concrete/constraint.ts"],"sourcesContent":["import { Timing } from '@/timing/contract'\n\nexport * from './concrete'\nexport * from './contract'\n\n\nexport const withTiming = async (timing: Timing, f: (timing: Timing) => Promise<void>) => {\n    try {\n        await f(timing)\n    } finally {\n        await timing.terminate()\n    }\n}\n","import { TimeConstraint, Timing } from \"../contract\";\nimport fs from 'fs';\nimport * as path from 'path';\n\ntype Locker = {\n    [key: string]: string // 本当はvalueはdateだが、全部parseしてdateにするのは非効率なのでstringで保持する\n}\n\nexport class FileTiming implements Timing {\n    private locker: Locker = {}\n\n    constructor(private readonly filepath: string) {\n        const dir = path.dirname(this.filepath);\n\n        // ディレクトリが存在しない場合は作成\n        if (!fs.existsSync(dir)) {\n            fs.mkdirSync(dir, { recursive: true });\n        }\n\n        // ファイルが存在しない場合は作成\n        if (!fs.existsSync(this.filepath)) {\n            this.flush()\n            return\n        }\n\n        this.read()\n    }\n\n    private read() {\n        this.locker = JSON.parse(fs.readFileSync(this.filepath, 'utf-8'))\n    }\n\n    private flush() {\n        fs.writeFileSync(this.filepath, JSON.stringify(this.locker), 'utf-8')\n    }\n\n    async allow({\n        key,\n        date,\n    }: {\n        key: string,\n        date: Date,\n    }) {\n        if (this.locker[key] === undefined) {\n            return true\n        }\n\n        const nextTime = new Date(this.locker[key])\n\n        return date >= nextTime\n    }\n\n    async complete({\n        key,\n        constraint,\n        date,\n    }: {\n        key: string,\n        constraint: TimeConstraint,\n        date: Date,\n    }) {\n        this.locker[key] = constraint.next(date).toISOString()\n        this.flush()\n    }\n\n    async terminate() { }\n\n    async list() {\n        return this.locker as {\n            [key: string]: string\n        }\n    }\n}\n\n","import { TimeConstraint, Timing } from \"@/timing/contract\";\nimport { Redis } from \"ioredis\";\nimport { setTimeout } from \"timers/promises\";\nimport { Logger } from \"winston\";\n\nexport type RedisTimingInput = {\n    host: string, port: number, keyPrefix?: string, logger?: Logger\n}\nexport class RedisTiming implements Timing {\n    private constructor(private readonly client: Redis) { }\n\n    static async init({ host, port, keyPrefix, logger }: RedisTimingInput) {\n        const client = new Redis({\n            host,\n            port,\n            keyPrefix,\n            retryStrategy(times) {\n                const delay = Math.min(times * 50, 2000);\n                return delay;\n            },\n            lazyConnect: true,\n        })\n\n        // エラーイベントのハンドリング\n        client.on('error', (err) => {\n            logger !== undefined\n                ? logger.error('Redis connection error:', err)\n                : console.error('Redis connection error:', err)\n        })\n\n        const maxRetry = 5\n        let times = 1\n        let connected = false\n\n        while (times <= maxRetry && !connected) {\n            try {\n                await client.connect();  // 明示的に接続を開始\n                connected = true\n            } catch (e) {\n                console.log(`error ${times}`)\n                const delay = Math.min(times * 50, 2000);\n                await setTimeout(delay)\n                times++\n            }\n        }\n\n        if (!connected) {\n            await client.disconnect(false)\n            throw new Error('Failed to connect to Redis');\n        }\n\n        return new RedisTiming(client)\n    }\n\n    async allow({\n        key,\n        date,\n    }: { key: string, date: Date; }) {\n        // TTLで勝手に消えるのでkeyで取得できたらfalse, なかったらtrue\n        const result = await this.client.exists(key)\n        return result === 0\n    }\n\n    async complete({\n        key,\n        constraint,\n        date,\n    }: { key: string, constraint: TimeConstraint, date: Date; }) {\n        const next = constraint.next(date).getTime()\n        const ttl = Math.floor((next - date.getTime()) / 1000); // TTLを秒単位で計算\n\n        // nextまでの時間をTTLとしてredisに保存する\n        // keyはkeyでvalueはなくてもいい\n        if (ttl > 0) {\n            await this.client.set(key, '', 'EX', ttl); // TTLを設定してキーを保存\n        }\n    }\n\n    async terminate() {\n        await this.client.quit()\n    }\n\n    async list() {\n        const result: { [key: string]: string } = {};\n        const keys = await this.client.keys('*'); // Redisに保存されている全てのキーを取得\n        const prefix = this.client.options.keyPrefix || ''; // keyPrefixを取得\n\n        for (const fullKey of keys) {\n            const key = fullKey.replace(prefix, ''); // keyPrefixを取り除いたキー\n            const ttl = await this.client.ttl(key); // フルキーでTTLを取得\n            if (ttl > 0) {\n                const expirationTimestamp = Date.now() + ttl * 1000; // 現在時刻にTTLを加えてミリ秒に変換\n                const expirationDate = new Date(expirationTimestamp); // Dateオブジェクトに変換\n                result[key] = expirationDate.toISOString(); // ISO 8601形式の文字列で返す\n            } else {\n                result[key] = 'No TTL'; // TTLが設定されていないキーはその旨を記載\n            }\n        }\n\n        return result;\n    }\n}\n","\nimport { TimeConstraint } from \"@/timing/contract\"\nimport { AtLeastOne } from \"@/util/types\"\n\nexport class Immediate implements TimeConstraint {\n    next(date: Date): Date {\n        return date\n    }\n}\n\nexport class Rate implements TimeConstraint {\n    constructor(private readonly param: AtLeastOne<{\n        h: number,\n        m: number,\n    }>) { }\n\n    next(date: Date): Date {\n        const h_ms = (this.param.h || 0) * 60 * 60 * 1000\n        const m_ms = (this.param.m || 0) * 60 * 1000\n        const timestamp = date.getTime()\n\n        return new Date(timestamp + h_ms + m_ms)\n    }\n}\n\nexport class Daily implements TimeConstraint {\n    constructor(private readonly param: {\n        h: number,\n        m: number,\n    }) { }\n\n    next(date: Date): Date {\n        const base = new Date(\n            Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), this.param.h, this.param.m)\n        )\n\n        return date <= base\n            ? base\n            : (() => {\n                base.setDate(base.getDate() + 1)\n                return base\n            })()\n    }\n}\n"],"mappings":"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","names":["fs","times"]}